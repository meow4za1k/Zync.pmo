--[[
    Zync.pmo UI Library
    
    A minimalist gaming menu UI with tab system for Roblox
    
    Author: Claude
    Version: 1.0
]]

-- Library Module
local ZyncLib = {}
ZyncLib.__index = ZyncLib

-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local SoundService = game:GetService("SoundService")

-- Constants
ZyncLib.Constants = {
    HIGHLIGHT_COLOR = Color3.fromRGB(81, 81, 189),
    DEFAULT_COLOR = Color3.fromRGB(255, 255, 255),
    UNSELECTED_COLOR = Color3.fromRGB(200, 200, 200),
    KEYBIND_COLOR = Color3.fromRGB(150, 150, 150),
    SHADOW_COLOR = Color3.fromRGB(0, 0, 0),
    DROPDOWN_BG = Color3.fromRGB(30, 30, 30),
    TWEEN_SPEED = 0.2,
    TWEEN_STYLE = Enum.EasingStyle.Quart,
    TWEEN_DIRECTION = Enum.EasingDirection.Out
}

-- Sound definitions
ZyncLib.SoundIDs = {
    HOVER = "rbxassetid://4681278859",
    CLICK = "rbxassetid://5942420465",
    TOGGLE_ON = "rbxassetid://6042583705",
    TOGGLE_OFF = "rbxassetid://6042583723",
    NAVIGATION = "rbxassetid://255473262"
}

-----------------------------------------------------------
-- HELPER CLASSES
-----------------------------------------------------------

-- Tab Class
local Tab = {}
Tab.__index = Tab

-- Option Classes
local Toggle = {}
Toggle.__index = Toggle

local Button = {}
Button.__index = Button

local Dropdown = {}
Dropdown.__index = Dropdown

local Slider = {}
Slider.__index = Slider

local Keybind = {}
Keybind.__index = Keybind

-- ScriptManager for toggle scripts
local ScriptManager = {}
ScriptManager.__index = ScriptManager

-----------------------------------------------------------
-- SCRIPT MANAGER IMPLEMENTATION
-----------------------------------------------------------

-- Create a new script manager
function ScriptManager.new()
    local self = setmetatable({}, ScriptManager)
    self.running = {}
    return self
end

-- Run a script with toggle capability
function ScriptManager:RunScript(id, onFn, offFn)
    if self.running[id] then
        self:StopScript(id)
        return false
    else
        -- Store script data
        self.running[id] = {
            connections = {},
            cleanupFns = {},
            offFn = offFn
        }
        
        -- Execute the script
        if typeof(onFn) == "function" then
            local env = getfenv(onFn)
            
            -- Add helper functions to environment
            env.RegisterConnection = function(conn)
                table.insert(self.running[id].connections, conn)
                return conn
            end
            
            env.RegisterCleanup = function(fn)
                table.insert(self.running[id].cleanupFns, fn)
                return fn
            end
            
            env.CreateLoop = function(interval, fn)
                local running = true
                local conn
                
                if interval < 0.01 then
                    conn = RunService.RenderStepped:Connect(function(dt)
                        if running then fn(dt) end
                    end)
                else
                    conn = spawn(function()
                        while running and wait(interval) do
                            fn(interval)
                        end
                    end)
                end
                
                table.insert(self.running[id].cleanupFns, function()
                    running = false
                    if typeof(conn) == "RBXScriptConnection" then
                        conn:Disconnect()
                    end
                end)
                
                return {
                    Stop = function()
                        running = false
                        if typeof(conn) == "RBXScriptConnection" then
                            conn:Disconnect()
                        end
                    end
                }
            end
            
            -- Run the script
            local success, result = pcall(onFn)
            if not success then
                warn("Script execution error: " .. tostring(result))
            end
            
            -- Store result for use with offFn
            self.running[id].result = result
        end
        
        return true
    end
end

-- Stop a running script
function ScriptManager:StopScript(id)
    local scriptData = self.running[id]
    if scriptData then
        -- Disconnect all connections
        for _, conn in ipairs(scriptData.connections) do
            if typeof(conn) == "RBXScriptConnection" and conn.Connected then
                conn:Disconnect()
            end
        end
        
        -- Run cleanup functions
        for _, fn in ipairs(scriptData.cleanupFns) do
            pcall(fn)
        end
        
        -- Run off script if provided
        if scriptData.offFn and typeof(scriptData.offFn) == "function" then
            pcall(function()
                scriptData.offFn(scriptData.result)
            end)
        end
        
        -- Remove from running scripts
        self.running[id] = nil
        return true
    end
    return false
end

-- Check if a script is running
function ScriptManager:IsRunning(id)
    return self.running[id] ~= nil
end

-----------------------------------------------------------
-- TAB IMPLEMENTATION
-----------------------------------------------------------

-- Create a new tab
function Tab.new(name, parent)
    local self = setmetatable({}, Tab)
    self.name = name
    self.parent = parent
    self.expanded = false
    self.options = {}
    return self
end

-- Add a toggle option to the tab
function Tab:AddToggle(name, settings)
    settings = settings or {}
    local toggle = Toggle.new(name, self, settings)
    table.insert(self.options, toggle)
    
    if self.parent.initialized then
        self.parent:Render()
    end
    
    return toggle
end

-- Add a button option to the tab
function Tab:AddButton(name, settings)
    settings = settings or {}
    local button = Button.new(name, self, settings)
    table.insert(self.options, button)
    
    if self.parent.initialized then
        self.parent:Render()
    end
    
    return button
end

-- Add a dropdown option to the tab
function Tab:AddDropdown(name, settings)
    settings = settings or {}
    local dropdown = Dropdown.new(name, self, settings)
    table.insert(self.options, dropdown)
    
    if self.parent.initialized then
        self.parent:Render()
    end
    
    return dropdown
end

-- Add a slider option to the tab
function Tab:AddSlider(name, settings)
    settings = settings or {}
    local slider = Slider.new(name, self, settings)
    table.insert(self.options, slider)
    
    if self.parent.initialized then
        self.parent:Render()
    end
    
    return slider
end

-- Add a keybind option to the tab
function Tab:AddKeybind(name, settings)
    settings = settings or {}
    local keybind = Keybind.new(name, self, settings)
    table.insert(self.options, keybind)
    
    if self.parent.initialized then
        self.parent:Render()
    end
    
    return keybind
end

-----------------------------------------------------------
-- TOGGLE IMPLEMENTATION
-----------------------------------------------------------

-- Create a new toggle option
function Toggle.new(name, parent, settings)
    local self = setmetatable({}, Toggle)
    self.name = name
    self.parent = parent
    self.type = "toggle"
    self.values = settings.values or {"« OFF", "« ON"}
    self.value = settings.default or self.values[1]
    self.keybind = settings.keybind
    self.callback = settings.callback
    self.scriptId = settings.scriptId or (parent.name .. "_" .. name)
    self.onScript = settings.onScript
    self.offScript = settings.offScript
    return self
end

-- Set the toggle value
function Toggle:SetValue(value)
    self.value = value
    if self.callback then
        self.callback(value)
    end
    
    -- Handle script execution
    if self.onScript then
        local isOn = string.find(value, "ON") ~= nil or 
                    (value ~= "« OFF" and value ~= "«OFF»")
        
        if isOn then
            self.parent.parent.scriptManager:RunScript(self.scriptId, self.onScript, self.offScript)
            self.parent.parent:PlaySound("toggleOn")
        else
            self.parent.parent.scriptManager:StopScript(self.scriptId)
            self.parent.parent:PlaySound("toggleOff")
        end
    end
    
    self.parent.parent:Render()
    return self
end

-- Cycle to the next value
function Toggle:Cycle()
    -- Find current value index
    local currentIndex = 1
    for i, val in ipairs(self.values) do
        if val == self.value then
            currentIndex = i
            break
        end
    end
    
    -- Cycle to next value
    currentIndex = currentIndex % #self.values + 1
    self:SetValue(self.values[currentIndex])
    return self
end

-- Set the keybind
function Toggle:SetKeybind(key)
    self.keybind = key
    self.parent.parent:Render()
    return self
end

-----------------------------------------------------------
-- BUTTON IMPLEMENTATION
-----------------------------------------------------------

-- Create a new button option
function Button.new(name, parent, settings)
    local self = setmetatable({}, Button)
    self.name = name
    self.parent = parent
    self.type = "button"
    self.keybind = settings.keybind
    self.callback = settings.callback or function() end
    return self
end

-- Call the button callback
function Button:Click()
    if self.callback then
        self.callback()
    end
    self.parent.parent:PlaySound("click")
    return self
end

-- Set the keybind
function Button:SetKeybind(key)
    self.keybind = key
    self.parent.parent:Render()
    return self
end

-----------------------------------------------------------
-- DROPDOWN IMPLEMENTATION
-----------------------------------------------------------

-- Create a new dropdown option
function Dropdown.new(name, parent, settings)
    local self = setmetatable({}, Dropdown)
    self.name = name
    self.parent = parent
    self.type = "dropdown"
    self.values = settings.values or {"Option 1", "Option 2", "Option 3"}
    self.value = settings.default or self.values[1]
    self.keybind = settings.keybind
    self.callback = settings.callback
    self.scriptId = settings.scriptId or (parent.name .. "_" .. name)
    self.onScript = settings.onScript
    self.offScript = settings.offScript
    return self
end

-- Set the dropdown value
function Dropdown:SetValue(value)
    self.value = value
    if self.callback then
        self.callback(value)
    end
    
    -- Handle script execution if applicable
    if self.onScript then
        if value ~= self.values[1] then -- Assume first value is "off" state
            self.parent.parent.scriptManager:RunScript(self.scriptId, self.onScript, self.offScript)
        else
            self.parent.parent.scriptManager:StopScript(self.scriptId)
        end
    end
    
    self.parent.parent:Render()
    return self
end

-- Cycle to the next value
function Dropdown:Cycle()
    -- Find current value index
    local currentIndex = 1
    for i, val in ipairs(self.values) do
        if val == self.value then
            currentIndex = i
            break
        end
    end
    
    -- Cycle to next value
    currentIndex = currentIndex % #self.values + 1
    self:SetValue(self.values[currentIndex])
    return self
end

-- Set the keybind
function Dropdown:SetKeybind(key)
    self.keybind = key
    self.parent.parent:Render()
    return self
end

-----------------------------------------------------------
-- SLIDER IMPLEMENTATION
-----------------------------------------------------------

-- Create a new slider option
function Slider.new(name, parent, settings)
    local self = setmetatable({}, Slider)
    self.name = name
    self.parent = parent
    self.type = "slider"
    self.min = settings.min or 0
    self.max = settings.max or 100
    self.value = settings.default or self.min
    self.increment = settings.increment or 1
    self.keybind = settings.keybind
    self.callback = settings.callback
    self.formatValue = settings.formatValue or function(val) return tostring(val) end
    self.suffix = settings.suffix or ""
    return self
end

-- Set the slider value
function Slider:SetValue(value)
    -- Constrain to min/max
    value = math.clamp(value, self.min, self.max)
    
    -- Round to nearest increment
    value = math.floor((value - self.min) / self.increment + 0.5) * self.increment + self.min
    
    self.value = value
    
    if self.callback then
        self.callback(value)
    end
    
    self.parent.parent:Render()
    return self
end

-- Increment the slider value
function Slider:Increment(amount)
    self:SetValue(self.value + (amount or self.increment))
    return self
end

-- Set the keybind
function Slider:SetKeybind(key)
    self.keybind = key
    self.parent.parent:Render()
    return self
end

-----------------------------------------------------------
-- KEYBIND IMPLEMENTATION
-----------------------------------------------------------

-- Create a new keybind option
function Keybind.new(name, parent, settings)
    local self = setmetatable({}, Keybind)
    self.name = name
    self.parent = parent
    self.type = "keybind"
    self.value = settings.default or "None"
    self.callback = settings.callback
    return self
end

-- Set the keybind value
function Keybind:SetValue(key)
    self.value = key
    if self.callback then
        self.callback(key)
    end
    
    self.parent.parent:Render()
    return self
end

-----------------------------------------------------------
-- ZYNCLIB IMPLEMENTATION
-----------------------------------------------------------

-- Create a new menu
function ZyncLib.new(title, settings)
    local self = setmetatable({}, ZyncLib)
    settings = settings or {}
    
    -- Initialize properties
    self.title = title or "Zync.pmo"
    self.width = settings.width or 200
    self.tabs = {}
    self.sounds = {}
    self.initialized = false
    
    -- Create script manager
    self.scriptManager = ScriptManager.new()
    
    -- UI state
    self.state = {
        selectedTab = 1,
        selectedOption = 0,
        expandedTabs = {},
        menuEnabled = true,
        minimized = false,
        isDragging = false,
        dragOffset = nil,
        keybindOpen = false,
        dropdownOpen = false,
        lastHoveredElement = nil
    }
    
    -- Common keybinds for dropdown
    self.commonKeybinds = settings.commonKeybinds or {
        "F", "G", "H", "J", "K",
        "Z", "X", "C", "V", "B",
        "1", "2", "3", "4", "5"
    }
    
    return self
end

-- Initialize the UI
function ZyncLib:Init()
    -- Create the UI elements
    self:CreateUI()
    
    -- Set up sound system
    self:SetupSounds()
    
    -- Set up input handlers
    self:SetupInputHandlers()
    
    -- Start shadow animation
    self:StartShadowAnimation()
    
    -- Mark as initialized
    self.initialized = true
    
    -- Set first tab as expanded by default
    if #self.tabs > 0 then
        self.state.expandedTabs[1] = true
        self:Render()
    end
    
    return self
end

-- Create the UI elements
function ZyncLib:CreateUI()
    -- Create ScreenGui
    self.screenGui = Instance.new("ScreenGui")
    self.screenGui.Name = "ZyncMenu"
    self.screenGui.ResetOnSpawn = false
    self.screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    self.screenGui.DisplayOrder = 999
    self.screenGui.IgnoreGuiInset = true
    
    -- Try to parent to CoreGui, fallback to PlayerGui
    pcall(function()
        if RunService:IsStudio() then
            self.screenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
        else
            self.screenGui.Parent = game.CoreGui
        end
    end)
    
    if not self.screenGui.Parent then
        self.screenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
    end
    
    -- Create glow/shadow effect
    self.glowContainer = Instance.new("Frame")
    self.glowContainer.Name = "GlowContainer"
    self.glowContainer.BackgroundTransparency = 1
    self.glowContainer.Position = UDim2.new(0, 6, 0, 6)
    self.glowContainer.Size = UDim2.new(0, self.width + 8, 0, 208)
    self.glowContainer.ZIndex = 998
    self.glowContainer.Parent = self.screenGui
    
    -- Create shadow layers
    for i = 1, 3 do
        local shadow = Instance.new("Frame")
        shadow.Name = "Shadow_" .. i
        shadow.BackgroundColor3 = ZyncLib.Constants.SHADOW_COLOR
        shadow.BorderSizePixel = 0
        shadow.Position = UDim2.new(0, -i, 0, -i)
        shadow.Size = UDim2.new(1, i*2, 1, i*2)
        shadow.BackgroundTransparency = 0.7 + (i * 0.1)
        shadow.ZIndex = 997 - i
        shadow.Parent = self.glowContainer
    end
    
    -- Create main frame
    self.mainFrame = Instance.new("Frame")
    self.mainFrame.Name = "MainFrame"
    self.mainFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    self.mainFrame.BackgroundTransparency = 0.2
    self.mainFrame.BorderSizePixel = 0
    self.mainFrame.Position = UDim2.new(0, 10, 0, 10)
    self.mainFrame.Size = UDim2.new(0, self.width, 0, 200)
    self.mainFrame.ZIndex = 999
    self.mainFrame.Parent = self.screenGui
    
    -- Create drag handle
    self.dragHandle = Instance.new("Frame")
    self.dragHandle.Name = "DragHandle"
    self.dragHandle.BackgroundTransparency = 1
    self.dragHandle.Position = UDim2.new(0, 0, 0, 0)
    self.dragHandle.Size = UDim2.new(1, 0, 0, 20)
    self.dragHandle.ZIndex = 1000
    self.dragHandle.Parent = self.mainFrame
    
    -- Create title
    self.titleLabel = Instance.new("TextLabel")
    self.titleLabel.Name = "TitleLabel"
    self.titleLabel.BackgroundTransparency = 1
    self.titleLabel.Position = UDim2.new(0, 5, 0, 5)
    self.titleLabel.Size = UDim2.new(1, -10, 0, 15)
    self.titleLabel.Font = Enum.Font.RobotoMono
    self.titleLabel.Text = self.title
    self.titleLabel.TextColor3 = ZyncLib.Constants.DEFAULT_COLOR
    self.titleLabel.TextSize = 14
    self.titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    self.titleLabel.ZIndex = 1000
    self.titleLabel.Parent = self.mainFrame
    
    -- Create separator
    self.separator = Instance.new("Frame")
    self.separator.Name = "Separator"
    self.separator.BackgroundColor3 = ZyncLib.Constants.DEFAULT_COLOR
    self.separator.BorderSizePixel = 0
    self.separator.Position = UDim2.new(0, 5, 0, 20)
    self.separator.Size = UDim2.new(1, -10, 0, 1)
    self.separator.ZIndex = 1000
    self.separator.Parent = self.mainFrame
    
    -- Create menu container
    self.menuContainer = Instance.new("ScrollingFrame")
    self.menuContainer.Name = "MenuContainer"
    self.menuContainer.BackgroundTransparency = 1
    self.menuContainer.Position = UDim2.new(0, 5, 0, 25)
    self.menuContainer.Size = UDim2.new(1, -10, 1, -30)
    self.menuContainer.CanvasSize = UDim2.new(0, 0, 0, 0)
    self.menuContainer.ScrollBarThickness = 0
    self.menuContainer.ScrollingDirection = Enum.ScrollingDirection.Y
    self.menuContainer.AutomaticCanvasSize = Enum.AutomaticSize.Y
    self.menuContainer.ZIndex = 1000
    self.menuContainer.Parent = self.mainFrame
    
    -- Create dropdown container (hidden initially)
    self.dropdownContainer = Instance.new("Frame")
    self.dropdownContainer.Name = "DropdownContainer"
    self.dropdownContainer.BackgroundColor3 = ZyncLib.Constants.DROPDOWN_BG
    self.dropdownContainer.BorderSizePixel = 0
    self.dropdownContainer.Position = UDim2.new(0, 0, 0, 0)
    self.dropdownContainer.Size = UDim2.new(0, 120, 0, 100)
    self.dropdownContainer.Visible = false
    self.dropdownContainer.ZIndex = 1100
    self.dropdownContainer.Parent = self.screenGui
    
    -- Create keybind dropdown (initially hidden)
    self.keybindDropdown = Instance.new("Frame")
    self.keybindDropdown.Name = "KeybindDropdown"
    self.keybindDropdown.BackgroundColor3 = ZyncLib.Constants.DROPDOWN_BG
    self.keybindDropdown.BorderSizePixel = 0
    self.keybindDropdown.Position = UDim2.new(0, 0, 0, 0)
    self.keybindDropdown.Size = UDim2.new(0, 120, 0, 100)
    self.keybindDropdown.Visible = false
    self.keybindDropdown.ZIndex = 1100
    self.keybindDropdown.Parent = self.screenGui
end

-- Set up sound system
function ZyncLib:SetupSounds()
    -- Create sound group
    self.soundGroup = Instance.new("SoundGroup")
    self.soundGroup.Name = "ZyncSounds"
    self.soundGroup.Parent = SoundService
    
    -- Create sounds
    self:CreateSound("hover", ZyncLib.SoundIDs.HOVER, 0.2)
    self:CreateSound("click", ZyncLib.SoundIDs.CLICK, 0.3)
    self:CreateSound("toggleOn", ZyncLib.SoundIDs.TOGGLE_ON, 0.4)
    self:CreateSound("toggleOff", ZyncLib.SoundIDs.TOGGLE_OFF, 0.4)
    self:CreateSound("nav", ZyncLib.SoundIDs.NAVIGATION, 0.2)
end

-- Create a sound object
function ZyncLib:CreateSound(name, id, volume)
    local sound = Instance.new("Sound")
    sound.Name = name .. "Sound"
    sound.SoundId = id
    sound.Volume = volume or 0.5
    sound.PlayOnRemove = false
    sound.SoundGroup = self.soundGroup
    sound.Parent = self.soundGroup
    
    self.sounds[name] = sound
end

-- Play a sound
function ZyncLib:PlaySound(name)
    local sound = self.sounds[name]
    if not sound then return end
    
    -- Clone to allow overlapping
    local soundClone = sound:Clone()
    soundClone.Parent = self.soundGroup
    soundClone:Play()
    
    -- Auto cleanup
    soundClone.Ended:Connect(function()
        soundClone:Destroy()
    end)
end

-- Set up input handlers
function ZyncLib:SetupInputHandlers()
    -- Make UI draggable
    self.dragHandle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            self.state.isDragging = true
            self.state.dragOffset = Vector2.new(
                input.Position.X - self.mainFrame.AbsolutePosition.X,
                input.Position.Y - self.mainFrame.AbsolutePosition.Y
            )
            self:PlaySound("click")
        end
    end)
    
    self.dragHandle.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            self.state.isDragging = false
            self.state.dragOffset = nil
        end
    end)
    
    -- Mouse movement for dragging
    UserInputService.InputChanged:Connect(function(input)
        if self.state.isDragging and self.state.dragOffset and input.UserInputType == Enum.UserInputType.MouseMovement then
            local newPosition = UDim2.new(
                0, 
                input.Position.X - self.state.dragOffset.X,
                0, 
                input.Position.Y - self.state.dragOffset.Y
            )
            self.mainFrame.Position = newPosition
            self.glowContainer.Position = UDim2.new(
                0,
                newPosition.X.Offset - 4,
                0,
                newPosition.Y.Offset - 4
            )
            
            -- Close any open dropdowns when dragging
            self:CloseAllDropdowns()
        end
    end)
    
    -- Title double-click for minimize
    self.titleLabel.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            -- Check for double click
            if self.titleLabel.LastClickTime and tick() - self.titleLabel.LastClickTime < 0.5 then
                self:ToggleMinimized()
                self.titleLabel.LastClickTime = nil
            else
                self.titleLabel.LastClickTime = tick()
                self:PlaySound("click")
            end
        end
    end)
    
    -- Add hover sound to title
    self.titleLabel.MouseEnter:Connect(function()
        if self.state.lastHoveredElement ~= self.titleLabel then
            self:PlaySound("hover")
            self.state.lastHoveredElement = self.titleLabel
        end
    end)
    
    -- Keyboard navigation
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed or not self.state.menuEnabled then return end
        
        -- Handle special keys
        if input.KeyCode == Enum.KeyCode.Home then
            -- Toggle menu visibility
            self:ToggleVisibility()
        elseif input.KeyCode == Enum.KeyCode.Up then
            -- Move selection up
            self:Navigate(-1)
        elseif input.KeyCode == Enum.KeyCode.Down then
            -- Move selection down
            self:Navigate(1)
        elseif input.KeyCode == Enum.KeyCode.Return or input.KeyCode == Enum.KeyCode.Space then
            -- Select current option
            self:HandleSelect()
        elseif input.KeyCode == Enum.KeyCode.Escape then
            -- Close all dropdowns
            self:CloseAllDropdowns()
        end
        
        -- Check for custom keybinds
        for tabIndex, tab in ipairs(self.tabs) do
            for optionIndex, option in ipairs(tab.options) do
                if option.keybind then
                    local keyName = string.upper(option.keybind)
                    local keyCode = Enum.KeyCode[keyName]
                    if keyCode and input.KeyCode == keyCode then
                        self.state.selectedTab = tabIndex
                        self.state.selectedOption = optionIndex
                        
                        -- Handle different option types
                        if option.type == "toggle" or option.type == "dropdown" then
                            option:Cycle()
                        elseif option.type == "button" then
                            option:Click()
                        elseif option.type == "slider" then
                            option:Increment()
                        end
                    end
                end
            end
        end
    end)
    
    -- Mouse wheel scrolling
    UserInputService.InputChanged:Connect(function(input, gameProcessed)
        if gameProcessed or not self.state.menuEnabled or self.state.minimized then return end
        
        if input.UserInputType == Enum.UserInputType.MouseWheel then
            if input.Position.Z > 0 then
                -- Scroll up
                self:Navigate(-1)
            else
                -- Scroll down
                self:Navigate(1)
            end
        end
    end)
end

-- Start shadow animation
function ZyncLib:StartShadowAnimation()
    spawn(function()
        local pulseAmount = 0.05
        local pulseSpeed = 0.5
        local counter = 0
        
        while self.screenGui and self.screenGui.Parent and wait(0.03) do
            counter = counter + 0.05
            local pulseFactor = (math.sin(counter * pulseSpeed) + 1) / 2 * pulseAmount
            
            if self.glowContainer then
                for i, layer in ipairs(self.glowContainer:GetChildren()) do
                    if not self.state.isDragging and not self.state.minimized then
                        layer.BackgroundTransparency = 0.7 + (i * 0.1) - pulseFactor
                    end
                end
            end
        end
    end)
end

-- Add a new tab
function ZyncLib:AddTab(name)
    local tab = Tab.new(name, self)
    table.insert(self.tabs, tab)
    
    -- Set first tab as expanded by default
    if #self.tabs == 1 then
        self.state.expandedTabs[1] = true
    else
        self.state.expandedTabs[#self.tabs] = false
    end
    
    if self.initialized then
        self:Render()
    end
    
    return tab
end

-- Toggle tab expansion
function ZyncLib:ToggleTab(tabIndex)
    self.state.expandedTabs[tabIndex] = not self.state.expandedTabs[tabIndex]
    
    -- Close any open dropdowns
    self:CloseAllDropdowns()
    
    self:Render()
end

-- Close all dropdowns
function ZyncLib:CloseAllDropdowns()
    -- Close keybind dropdown if open
    if self.state.keybindOpen then
        self.keybindDropdown.Visible = false
        self.state.keybindOpen = false
    end
    
    -- Close options dropdown if open
    if self.state.dropdownOpen then
        self.dropdownContainer.Visible = false
        self.state.dropdownOpen = false
    end
end

-- Toggle menu visibility
function ZyncLib:ToggleVisibility()
    self.state.menuEnabled = not self.state.menuEnabled
    
    if self.state.menuEnabled then
        self:PlaySound("toggleOn")
    else
        self:PlaySound("toggleOff")
    end
    
    self.screenGui.Enabled = self.state.menuEnabled
    
    -- Close all dropdowns
    self:CloseAllDropdowns()
end

-- Toggle minimized state
function ZyncLib:ToggleMinimized()
    self.state.minimized = not self.state.minimized
    self:PlaySound("click")
    
    -- Close all dropdowns
    self:CloseAllDropdowns()
    
    self:Render()
end

-- Navigate through menu
function ZyncLib:Navigate(direction)
    if self.state.minimized then return end
    
    -- Close all dropdowns
    self:CloseAllDropdowns()
    
    -- Play navigation sound
    self:PlaySound("nav")
    
    if self.state.selectedOption == 0 then
        -- On tab header
        if direction > 0 then
            -- Move to first option if tab is expanded, or next tab
            if self.state.expandedTabs[self.state.selectedTab] and #self.tabs[self.state.selectedTab].options > 0 then
                self.state.selectedOption = 1
            else
                self.state.selectedTab = self.state.selectedTab % #self.tabs + 1
            end
        else
            -- Move to previous tab
            self.state.selectedTab = (self.state.selectedTab - 2) % #self.tabs + 1
        end
    else
        -- On option
        if direction > 0 then
            -- Move to next option or next tab
            if self.state.selectedOption < #self.tabs[self.state.selectedTab].options then
                self.state.selectedOption = self.state.selectedOption + 1
            else
                self.state.selectedTab = self.state.selectedTab % #self.tabs + 1
                self.state.selectedOption = 0
            end
        else
            -- Move to previous option or tab header
            if self.state.selectedOption > 1 then
                self.state.selectedOption = self.state.selectedOption - 1
            else
                self.state.selectedOption = 0
            end
        end
    end
    
    self:Render()
end

-- Handle selection (Enter/Space key)
function ZyncLib:HandleSelect()
    -- Close all dropdowns
    self:CloseAllDropdowns()
    
    if self.state.selectedOption == 0 then
        -- Toggle tab expansion
        self:ToggleTab(self.state.selectedTab)
        self:PlaySound("click")
    else
        -- Handle option by type
        local option = self.tabs[self.state.selectedTab].options[self.state.selectedOption]
        
        if option.type == "toggle" or option.type == "dropdown" then
            option:Cycle()
        elseif option.type == "button" then
            option:Click()
        elseif option.type == "slider" then
            option:Increment()
        end
    end
end

-- Open keybind dropdown
function ZyncLib:OpenKeybindDropdown(tabIndex, optionIndex)
    -- Close any open dropdowns
    self:CloseAllDropdowns()
    
    -- Get option and position
    local option = self.tabs[tabIndex].options[optionIndex]
    local optionFrame = self.menuContainer:FindFirstChild("OptionFrame_" .. tabIndex .. "_" .. optionIndex)
    
    if not optionFrame then return end
    
    -- Clear dropdown
    for _, child in pairs(self.keybindDropdown:GetChildren()) do
        child:Destroy()
    end
    
    -- Position dropdown
    local absPos = optionFrame.AbsolutePosition
    self.keybindDropdown.Position = UDim2.new(0, absPos.X + optionFrame.AbsoluteSize.X - 50, 0, absPos.Y + 25)
    
    -- Create dropdown title
    local title = Instance.new("TextLabel")
    title.Name = "Title"
    title.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    title.BorderSizePixel = 0
    title.Size = UDim2.new(1, 0, 0, 20)
    title.Font = Enum.Font.RobotoMono
    title.Text = "Select Keybind"
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.TextSize = 14
    title.ZIndex = 1101
    title.Parent = self.keybindDropdown
    
    -- Create keybind options container
    local listFrame = Instance.new("Frame")
    listFrame.Name = "ListFrame"
    listFrame.BackgroundTransparency = 1
    listFrame.Position = UDim2.new(0, 0, 0, 20)
    listFrame.Size = UDim2.new(1, 0, 1, -20)
    listFrame.ZIndex = 1101
    listFrame.Parent = self.keybindDropdown
    
    -- Add keybind options
    for i, key in ipairs(self.commonKeybinds) do
        local item = Instance.new("TextButton")
        item.Name = "Key_" .. key
        item.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
        item.BorderSizePixel = 0
        item.Position = UDim2.new(0, 0, 0, (i-1) * 20)
        item.Size = UDim2.new(1, 0, 0, 20)
        item.Font = Enum.Font.RobotoMono
        item.Text = key
        item.TextColor3 = Color3.fromRGB(255, 255, 255)
        item.TextSize = 14
        item.ZIndex = 1101
        
        -- Highlight current keybind
        if option.keybind == key then
            item.BackgroundColor3 = ZyncLib.Constants.HIGHLIGHT_COLOR
        end
        
        -- Keybind selection handling
        item.MouseButton1Click:Connect(function()
            option:SetKeybind(key)
            self:PlaySound("click")
            self.keybindDropdown.Visible = false
            self.state.keybindOpen = false
            self:Render()
        end)
        
        -- Hover effect
        item.MouseEnter:Connect(function()
            if self.state.lastHoveredElement ~= item then
                self:PlaySound("hover")
                self.state.lastHoveredElement = item
                
                -- Highlight on hover
                if option.keybind ~= key then
                    item.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
                end
            end
        end)
        
        item.MouseLeave:Connect(function()
            -- Reset background when not hovering
            if option.keybind ~= key then
                item.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
            end
        end)
        
        item.Parent = listFrame
    end
    
    -- Set size and show
    self.keybindDropdown.Size = UDim2.new(0, 120, 0, 20 + (#self.commonKeybinds * 20))
    self.keybindDropdown.Visible = true
    self.state.keybindOpen = true
end

-- Render the UI
function ZyncLib:Render()
    -- Clear menu container
    for _, child in pairs(self.menuContainer:GetChildren()) do
        child:Destroy()
    end
    
    -- Handle minimized state
    if self.state.minimized then
        self.mainFrame.Size = UDim2.new(0, self.width, 0, 25)
        self.menuContainer.Visible = false
        return
    else
        self.menuContainer.Visible = true
    end
    
    -- Create menu items
    local yOffset = 0
    
    for tabIndex, tab in ipairs(self.tabs) do
        -- Create tab header with animated arrow
        local tabFrame = Instance.new("Frame")
        tabFrame.Name = "TabFrame_" .. tabIndex
        tabFrame.BackgroundTransparency = 1
        tabFrame.Position = UDim2.new(0, 0, 0, yOffset)
        tabFrame.Size = UDim2.new(1, 0, 0, 20)
        tabFrame.ZIndex = 1001
        tabFrame.Parent = self.menuContainer
        
        local arrowContainer = Instance.new("Frame")
        arrowContainer.Name = "ArrowContainer"
        arrowContainer.BackgroundTransparency = 1
        arrowContainer.Size = UDim2.new(0, 20, 0, 20)
        arrowContainer.ZIndex = 1002
        arrowContainer.Parent = tabFrame
        
        local arrow = Instance.new("TextLabel")
        arrow.Name = "Arrow"
        arrow.BackgroundTransparency = 1
        arrow.Position = UDim2.new(0.5, 0, 0.5, 0)
        arrow.Size = UDim2.new(0, 20, 0, 20)
        arrow.AnchorPoint = Vector2.new(0.5, 0.5)
        arrow.Font = Enum.Font.RobotoMono
        arrow.Text = "►" -- Default right arrow (when closed)
        arrow.TextColor3 = self.state.expandedTabs[tabIndex] and ZyncLib.Constants.HIGHLIGHT_COLOR or ZyncLib.Constants.DEFAULT_COLOR
        arrow.TextSize = 14
        arrow.Rotation = self.state.expandedTabs[tabIndex] and 90 or 0 -- Rotated when expanded
        arrow.ZIndex = 1003
        arrow.Parent = arrowContainer
        
        local tabHeader = Instance.new("TextLabel")
        tabHeader.Name = "Header"
        tabHeader.BackgroundTransparency = 1
        tabHeader.Position = UDim2.new(0, 20, 0, 0)
        tabHeader.Size = UDim2.new(1, -20, 1, 0)
        tabHeader.Font = Enum.Font.RobotoMono
        tabHeader.ZIndex = 1002
        
        -- Format tab header based on selection
        if self.state.selectedTab == tabIndex and self.state.selectedOption == 0 then
            tabHeader.Text = "_« " .. tab.name .. " _"
            tabHeader.TextColor3 = ZyncLib.Constants.HIGHLIGHT_COLOR
            arrow.TextColor3 = ZyncLib.Constants.HIGHLIGHT_COLOR
        else
            tabHeader.Text = "_« " .. tab.name .. " _"
            tabHeader.TextColor3 = ZyncLib.Constants.DEFAULT_COLOR
        end
        
        tabHeader.TextSize = 16
        tabHeader.TextXAlignment = Enum.TextXAlignment.Left
        tabHeader.Parent = tabFrame
        
        -- Tab Click handling
        tabFrame.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                self.state.selectedTab = tabIndex
                self.state.selectedOption = 0
                self:ToggleTab(tabIndex)
                self:PlaySound("click")
            end
        end)
        
        -- Tab hover sound
        tabFrame.MouseEnter:Connect(function()
            if self.state.lastHoveredElement ~= tabFrame then
                self:PlaySound("hover")
                self.state.lastHoveredElement = tabFrame
            end
        end)
        
        yOffset = yOffset + 20
        
        -- Add options if tab is expanded
        if self.state.expandedTabs[tabIndex] then
            for optionIndex, option in ipairs(tab.options) do
                local optionFrame = Instance.new("Frame")
                optionFrame.Name = "OptionFrame_" .. tabIndex .. "_" .. optionIndex
                optionFrame.BackgroundTransparency = 1
                optionFrame.Position = UDim2.new(0, 20, 0, yOffset)
                optionFrame.Size = UDim2.new(1, -20, 0, 20)
                optionFrame.ZIndex = 1001
                optionFrame.Parent = self.menuContainer
                
                local optionLabel = Instance.new("TextLabel")
                optionLabel.Name = "OptionLabel"
                optionLabel.BackgroundTransparency = 1
                optionLabel.Size = UDim2.new(0.5, 0, 1, 0)
                optionLabel.Font = Enum.Font.RobotoMono
                optionLabel.ZIndex = 1001
                
                -- Check if this option is selected
                local isSelected = (self.state.selectedTab == tabIndex and self.state.selectedOption == optionIndex)
                
                if isSelected then
                    optionLabel.Text = "» " .. option.name
                    optionLabel.TextColor3 = ZyncLib.Constants.HIGHLIGHT_COLOR
                else
                    optionLabel.Text = option.name
                    optionLabel.TextColor3 = ZyncLib.Constants.UNSELECTED_COLOR
                end
                
                optionLabel.TextSize = 14
                optionLabel.TextXAlignment = Enum.TextXAlignment.Left
                optionLabel.Parent = optionFrame
                
                -- Create value display based on option type
                if option.type == "toggle" or option.type == "dropdown" then
                    local optionValue = Instance.new("TextLabel")
                    optionValue.Name = "OptionValue"
                    optionValue.BackgroundTransparency = 1
                    optionValue.Position = UDim2.new(0.5, 0, 0, 0)
                    optionValue.Size = UDim2.new(0.3, 0, 1, 0)
                    optionValue.Font = Enum.Font.RobotoMono
                    optionValue.Text = option.value
                    optionValue.ZIndex = 1001
                    
                    if isSelected then
                        optionValue.TextColor3 = ZyncLib.Constants.HIGHLIGHT_COLOR
                    else
                        optionValue.TextColor3 = ZyncLib.Constants.UNSELECTED_COLOR
                    end
                    
                    optionValue.TextSize = 14
                    optionValue.TextXAlignment = Enum.TextXAlignment.Left
                    optionValue.Parent = optionFrame
                elseif option.type == "button" then
                    local buttonIndicator = Instance.new("TextLabel")
                    buttonIndicator.Name = "ButtonIndicator"
                    buttonIndicator.BackgroundTransparency = 1
                    buttonIndicator.Position = UDim2.new(0.5, 0, 0, 0)
                    buttonIndicator.Size = UDim2.new(0.3, 0, 1, 0)
                    buttonIndicator.Font = Enum.Font.RobotoMono
                    buttonIndicator.Text = "[ CLICK ]"
                    buttonIndicator.ZIndex = 1001
                    
                    if isSelected then
                        buttonIndicator.TextColor3 = ZyncLib.Constants.HIGHLIGHT_COLOR
                    else
                        buttonIndicator.TextColor3 = ZyncLib.Constants.UNSELECTED_COLOR
                    end
                    
                    buttonIndicator.TextSize = 14
                    buttonIndicator.TextXAlignment = Enum.TextXAlignment.Left
                    buttonIndicator.Parent = optionFrame
                elseif option.type == "slider" then
                    local sliderValue = Instance.new("TextLabel")
                    sliderValue.Name = "SliderValue"
                    sliderValue.BackgroundTransparency = 1
                    sliderValue.Position = UDim2.new(0.5, 0, 0, 0)
                    sliderValue.Size = UDim2.new(0.3, 0, 1, 0)
                    sliderValue.Font = Enum.Font.RobotoMono
                    sliderValue.Text = option.formatValue(option.value) .. option.suffix
                    sliderValue.ZIndex = 1001
                    
                    if isSelected then
                        sliderValue.TextColor3 = ZyncLib.Constants.HIGHLIGHT_COLOR
                    else
                        sliderValue.TextColor3 = ZyncLib.Constants.UNSELECTED_COLOR
                    end
                    
                    sliderValue.TextSize = 14
                    sliderValue.TextXAlignment = Enum.TextXAlignment.Left
                    sliderValue.Parent = optionFrame
                elseif option.type == "keybind" then
                    local keybindValue = Instance.new("TextLabel")
                    keybindValue.Name = "KeybindValue"
                    keybindValue.BackgroundTransparency = 1
                    keybindValue.Position = UDim2.new(0.5, 0, 0, 0)
                    keybindValue.Size = UDim2.new(0.3, 0, 1, 0)
                    keybindValue.Font = Enum.Font.RobotoMono
                    keybindValue.Text = option.value
                    keybindValue.ZIndex = 1001
                    
                    if isSelected then
                        keybindValue.TextColor3 = ZyncLib.Constants.HIGHLIGHT_COLOR
                    else
                        keybindValue.TextColor3 = ZyncLib.Constants.UNSELECTED_COLOR
                    end
                    
                    keybindValue.TextSize = 14
                    keybindValue.TextXAlignment = Enum.TextXAlignment.Left
                    keybindValue.Parent = optionFrame
                end
                
                -- Add keybind indicator if a keybind is set
                if option.keybind then
                    local keybindLabel = Instance.new("TextLabel")
                    keybindLabel.Name = "KeybindLabel"
                    keybindLabel.BackgroundTransparency = 1
                    keybindLabel.Position = UDim2.new(0.8, 0, 0, 0)
                    keybindLabel.Size = UDim2.new(0.2, 0, 1, 0)
                    keybindLabel.Font = Enum.Font.RobotoMono
                    keybindLabel.Text = "[" .. option.keybind .. "]"
                    keybindLabel.ZIndex = 1001
                    
                    if isSelected then
                        keybindLabel.TextColor3 = ZyncLib.Constants.HIGHLIGHT_COLOR
                    else
                        keybindLabel.TextColor3 = ZyncLib.Constants.KEYBIND_COLOR
                    end
                    
                    keybindLabel.TextSize = 12
                    keybindLabel.TextXAlignment = Enum.TextXAlignment.Right
                    keybindLabel.Parent = optionFrame
                end
                
                -- Option click handling
                optionFrame.InputBegan:Connect(function(input)
                    if input.UserInputType == Enum.UserInputType.MouseButton1 then
                        self.state.selectedTab = tabIndex
                        self.state.selectedOption = optionIndex
                        
                        -- Handle option by type
                        if option.type == "toggle" or option.type == "dropdown" then
                            option:Cycle()
                        elseif option.type == "button" then
                            option:Click()
                        elseif option.type == "slider" then
                            option:Increment()
                        end
                    elseif input.UserInputType == Enum.UserInputType.MouseButton2 and option.keybind ~= nil then
                        self.state.selectedTab = tabIndex
                        self.state.selectedOption = optionIndex
                        self:PlaySound("click")
                        self:OpenKeybindDropdown(tabIndex, optionIndex)
                    end
                end)
                
                -- Option hover sound
                optionFrame.MouseEnter:Connect(function()
                    if self.state.lastHoveredElement ~= optionFrame then
                        self:PlaySound("hover")
                        self.state.lastHoveredElement = optionFrame
                    end
                end)
                
                yOffset = yOffset + 20
            end
        end
    end
    
    -- Update main frame size based on content
    if not self.state.minimized then
        local newHeight = math.max(yOffset + 30, 60) -- +30 for title area, minimum of 60px
        self.mainFrame.Size = UDim2.new(0, self.width, 0, newHeight)
        self.glowContainer.Size = UDim2.new(0, self.width + 8, 0, newHeight + 8)
    end
end

-- Simple helper to print error and return nil
local function errorReturn(msg)
    warn("ZyncLib Error: " .. msg)
    return nil
end

-- Return the library
return ZyncLib
